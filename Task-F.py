# Задача F. Найти склад. Условие задачи под кодом, внизу. 
# (Источник: Тренировочный контест Яндекса)

# Принцип решения. На вход поступают дуги (рёбра) графа. Построим список связности,
# внутри которого будут находиться множества/сеты вершин, связанных между собой. Каждый 
# такой сегмент будет связан внутри, но изолирован от всех остальных сегментов списка. 
# Останется проверить связность между складом-заказчиком и складом-поставщиком.

import sys


def line_int():  # для считывания строк из консоли
    return [int(i) for i in sys.stdin.readline().split()]


def find_svaz(elem, svazi):  # из списка сетов возвращает индекс сета, в котором есть elem
    for _, st in enumerate(svazi):  # перебираем пары "индекс, сет"
        if elem in st:
            return _  # поиск прекращаем, возвращаем текущий индекс


n_svazi = int(sys.stdin.readline().strip())  # количество пар складов, рёбер графа
svazi = []  # связи как список сетов (сеты содержат связанные между собой вершины)
for _ in range(n_svazi):  # читаем входные данные для связей (рёбра графа)
    l, r = line_int()  # очередные "левая" и "правая" границы ребра/дуги графа (вершины)
    if not svazi:  # самая первая пара попадает в svazi в виде сета из 2-х элементов
        svazi.append({l, r})
    else:  # если svazi не пустой, то
        l_, r_ = -1, -1  # создаём индексы/флаги для l и r, поначалу они фиктивные -1
        for i, st in enumerate(svazi):  # i, st это индекс сета и сет в svazi
            if l in st:  # если вершина l найдена в текущем сете
                l_ = i  # запоминаем его индекс
                svazi[i].add(l)  # добавляем вершину в текущий сет, в нём все вершины связаны
            if r in st:  # аналогично для "правой" вершины, при этом
                r_ = i  # допускаем, что (l,r) могут во входных данных повторяться
                svazi[i].add(r)
        if (l_, r_) == (-1, -1):  # если обе вершины l и r новички, то
            svazi.append({l, r})  # дописываем сет из этой пары в конец svazi
        elif l_ == -1 and r_ >= 0:  # если вершина l новичок, а r не новичок, то
            svazi[r_].add(l)  # записываем l в сет, в котором находится r
        elif r_ == -1 and l_ >= 0:  # аналогично если r новичок, а l нет
            svazi[l_].add(r)
        elif r_ >= 0 and l_ >= 0:  # если обе вершины l и r не новички, то
            svazi[l_].update(svazi[r_])  # в сет, где сидит l, добавляем сет с r
            del svazi[r_]  # сет с r удаляем, а l теперь хранит их оба

# В итоге мы получили список svazi, в котором находятся сеты, содержащие
# связанные между собой вершины графа. Каждый сет от других сетов изолирован.
# Теперь остаётся проверить, что склад-заказчик и склад-поставщик находятся
# в одном и том же сете (т.е. индексы их сетов в списке svazi совпадают).

n_zakaz = int(sys.stdin.readline().strip())  # получаем количество заказов

for k in range(n_zakaz):  # перебираем построчно, для каждого заказа
    need, n_serv = line_int()  # считываем склад-заказчик и количество складов-поставщиков
    serv = line_int()  # склады-поставщики

    ans = []  # список, в который попадут склады-поставщики с нужной связью

    nd = find_svaz(need, svazi)  # находим индекс сета склада-заказчика

    for srv in serv:  # перебираем склады-поставщики,
        if srv in svazi[nd]:  # если они в одном сете со складом-заказчиком -
            ans.append(srv)  #  пополняем список ответов индексом склада

    print(len(ans), *ans)  # для заказа из текущей итерации печатаем ответ

exit(0)  # формальность


# Условие задачи
#
# Торговая сеть «Руки из плеч» состоит из нескольких магазинов-складов. В складской системе учёта они 
# обозначены уникальным целочисленным идентификатором. N пар магазинов-складов объединены в кластеры 
# по территориальному принципу.
# Периодически нужного товара не оказывается на определенном складе, и тогда товар может быть доставлен 
# с другого склада, но только из своего кластера, т.к. доставка товаров со складов другого кластера 
# нерентабельна.
# Напишите программу, которая будет показывать, с какого на какой склад может быть доставлен необходимый 
# товар.
#
#
# Формат ввода
# Первая строка содержит целое число N (до 10**6) — количество связей между складами.
# Следующие N строк описывают связи между складами. Каждая из них содержит целые числа Ui и Vi (до 10**9) 
# — идентификаторы соединённых складов.
# Следующая строка содержит целое число T (1≤T≤10**3) — количество запросов на доставку товара на склад 
# для доставки покупателю.
# Следующие (2*T) строк описывают запросы. Первая строка каждой пары содержит целые числа Xi и Ki (10**9,
# 1≤Ki≤100) — соответственно идентификатор склада, на который нужно доставить товар, и количество складов,
# содержащих товар. Вторая строка каждой пары содержит Ki целых чисел Yij (1≤Yij≤109) — идентификаторы 
# складов с товаром.
#
# Формат вывода
# Для каждого запроса в отдельной строке выведите сначала целое число Rj — количество складов, откуда можно 
# доставить товар. Затем выведите Rj целых чисел — номера складов, откуда можно доставить товар. Номера 
# складов следует выводить в том порядке, в котором они перечислены в описании соответствующего запроса во 
# входных данных.
