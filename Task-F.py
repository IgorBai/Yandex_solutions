# Задача F. Найти склад. Условие задачи под кодом, внизу. 
# (Источник: Тренировочный контест Яндекса)

##### Вариант 1 (он работает до 50% быстрее, но на столько же больше потребляет памяти)
# 
# Принцип решения. На вход поступают дуги (рёбра) графа. Построим словарь связности,
# внутри которого ключи - индексы складов (вершины графа), а значениями будут номера 
# сегментов. Элементы из одного сегмента связаны между собой, но изолированы от всех 
# остальных сегментов. Отличается номер сегмента - нет связи, и наоборот. 
# Останется проверить связность между складом-заказчиком и складом-поставщиком.

import sys


def line2list():  # для считывания из консоли строк и преобразования их в списки int
    return [int(i) for i in sys.stdin.readline().split()]


def edge2voc(elem_l, elem_r, voc_segments):  # получение дуг графа и сегментирование
    global seg_count  # счётчик сегментов (слияние сегментов приводит к пробелам в нумерации)
    l, r = -1, -1  # (пока фиктивные) флаги, указывают на номер сегмента связанных вершин
    if elem_l in voc_segments:  # если левая вершина в словаре -
        l = voc_segments[elem_l]  # получаем номер её сегмента
    if elem_r in voc_segments:  # если правая вершина в словаре -
        r = voc_segments[elem_r]  # получаем номер её сегмента

    if (l, r) == (-1, -1):  # если обе вершины l и r новички, то
        seg_count += 1  # даём новому сегменту новый номер
        voc_segments[elem_l] = seg_count  # заносим в сегмент левую и
        voc_segments[elem_r] = seg_count  # правую вершины
    elif l == -1 and r >= 0:  # если вершина l новичок, а r не новичок, то
        voc_segments[elem_l] = r  # новичку присваиваем номер сегмента r
    elif r == -1 and l >= 0:  # аналогично если r новичок, а l нет
        voc_segments[elem_r] = l  # новичку присваиваем номер сегмента l
    elif r >= 0 and l >= 0 and l != r:  # если обе вершины l и r не новички и в разных сегментах,
        # делаем слияние: все номера сегментов r меняем на l, остальные сегменты не трогаем
        voc_segments = {e:l if voc_segments[e] == r else voc_segments[e] for e in voc_segments}


seg_count = 0  # глобальная переменная для нумерации сегментов (т.е. групп связанных вершин)
segments = dict()  # в этом словаре ключи - вершины (склады), а значения - сегменты (группы)

n_svazi = int(sys.stdin.readline().strip())  # количество пар складов (рёбер графа)

for _ in range(n_svazi):  # читаем входные данные для связей (рёбра графа)
    l, r = line2list()  # условно левая и правая вершины ребра (дуги)
    edge2voc(l, r, segments)  # вызов функции, формирующей сегментированный словарь

n_zakaz = int(sys.stdin.readline().strip())  # получаем количество заказов

for k in range(n_zakaz):  # перебираем построчно, для каждого заказа
    need, n_serv = line2list()  # считываем склад-заказчик и количество складов-поставщиков
    serv = line2list()  # список складов-поставщиков, где есть нужный товар

    # если заказчик и поставщик в одном сегменте - пополняем список ответов
    ans = [srv for srv in serv if segments[srv] == segments[need]]
    print(len(ans), *ans)  # для заказа из текущей итерации печатаем ответ

exit(0)  # формальность

#####
##### Вариант 2 (он работает медленнее, но и памяти потребляет меньше)
#####

import sys


def line_int():  # для считывания строк из консоли
    return [int(i) for i in sys.stdin.readline().split()]


def find_svaz(elem, svazi):  # для списка сетов возвращает индекс сета, в котором есть elem
    for _, st in enumerate(svazi):  # перебираем пары "индекс, сет"
        if elem in st:
            return _  # поиск прекращаем, возвращаем текущий индекс


n_svazi = int(sys.stdin.readline().strip())  # количество пар складов, рёбер графа
svazi = []  # связи как список сетов (сеты содержат связанные между собой вершины)
for _ in range(n_svazi):  # читаем входные данные для связей (рёбра графа)
    l, r = line_int()  # очередные "левая" и "правая" границы ребра/дуги графа (вершины)
    if not svazi:  # самая первая пара попадает в svazi в виде сета из 2-х элементов
        svazi.append({l, r})
    else:  # если svazi не пустой, то
        l_, r_ = -1, -1  # создаём индексы/флаги для l и r, поначалу они фиктивные -1
        for i, st in enumerate(svazi):  # i, st это индекс сета и сет в svazi
            if l in st:  # если вершина l найдена в текущем сете
                l_ = i  # запоминаем его индекс
                svazi[i].add(l)  # добавляем вершину в текущий сет, в нём все вершины связаны
            if r in st:  # аналогично для "правой" вершины, при этом
                r_ = i  # допускаем, что (l,r) могут во входных данных повторяться
                svazi[i].add(r)
        if (l_, r_) == (-1, -1):  # если обе вершины l и r новички, то
            svazi.append({l, r})  # дописываем сет из этой пары в конец svazi
        elif l_ == -1 and r_ >= 0:  # если вершина l новичок, а r не новичок, то
            svazi[r_].add(l)  # записываем l в сет, в котором находится r
        elif r_ == -1 and l_ >= 0:  # аналогично если r новичок, а l нет
            svazi[l_].add(r)
        elif r_ >= 0 and l_ >= 0:  # если обе вершины l и r не новички, то
            svazi[l_].update(svazi[r_])  # в сет, где сидит l, добавляем сет с r
            del svazi[r_]  # сет с r удаляем, а l теперь хранит их оба

# В итоге мы получили список svazi, в котором находятся множества, содержащие
# связанные между собой вершины графа. Каждый сет от других сетов изолирован.
# Теперь остаётся проверить, что склад-заказчик и склад-поставщик находятся
# в одном и том же сете (т.е. индексы их сетов в списке svazi совпадают).

n_zakaz = int(sys.stdin.readline().strip())  # получаем количество заказов

for k in range(n_zakaz):  # перебираем построчно, для каждого заказа
    need, n_serv = line_int()  # считываем склад-заказчик и количество складов-поставщиков
    serv = line_int()  # склады-поставщики

    ans = []  # список, в который попадут склады-поставщики с нужной связью

    nd = find_svaz(need, svazi)  # находим индекс сета склада-заказчика

    for srv in serv:  # перебираем склады-поставщики,
        if srv in svazi[nd]:  # если они в одном сете со складом-заказчиком -
            ans.append(srv)  #  пополняем список ответов индексом склада

    print(len(ans), *ans)  # для заказа из текущей итерации печатаем ответ

exit(0)  # формальность

# Условие задачи
#
# Торговая сеть «Руки из плеч» состоит из нескольких магазинов-складов. В складской системе учёта они 
# обозначены уникальным целочисленным идентификатором. N пар магазинов-складов объединены в кластеры 
# по территориальному принципу.
# Периодически нужного товара не оказывается на определенном складе, и тогда товар может быть доставлен 
# с другого склада, но только из своего кластера, т.к. доставка товаров со складов другого кластера 
# нерентабельна.
# Напишите программу, которая будет показывать, с какого на какой склад может быть доставлен необходимый 
# товар.
#
#
# Формат ввода
# Первая строка содержит целое число N (до 10**6) — количество связей между складами.
# Следующие N строк описывают связи между складами. Каждая из них содержит целые числа Ui и Vi (до 10**9) 
# — идентификаторы соединённых складов.
# Следующая строка содержит целое число T (1≤T≤10**3) — количество запросов на доставку товара на склад 
# для доставки покупателю.
# Следующие (2*T) строк описывают запросы. Первая строка каждой пары содержит целые числа Xi и Ki (10**9,
# 1≤Ki≤100) — соответственно идентификатор склада, на который нужно доставить товар, и количество складов,
# содержащих товар. Вторая строка каждой пары содержит Ki целых чисел Yij (1≤Yij≤109) — идентификаторы 
# складов с товаром.
#
# Формат вывода
# Для каждого запроса в отдельной строке выведите сначала целое число Rj — количество складов, откуда можно 
# доставить товар. Затем выведите Rj целых чисел — номера складов, откуда можно доставить товар. Номера 
# складов следует выводить в том порядке, в котором они перечислены в описании соответствующего запроса во 
# входных данных.
